<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>퀴즈</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 0;
      font-family: "맑은 고딕", -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
      background: #f5f5f5;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
    }
    .app {
      background: #fff;
      max-width: 700px;
      width: 100%;
      margin: 16px;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      position: relative; /* 버전/진행 표시용 */
    }
    h1 {
      margin: 0 0 20px;
      font-size: 22px;
      text-align: center;
    }
    .btn {
      display: inline-block;
      padding: 10px 16px;
      margin: 6px 4px;
      font-size: 16px;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      background: #1976d2;
      color: #fff;
    }
    .btn.secondary {
      background: #777;
    }
    .btn.small {
      font-size: 14px;
      padding: 6px 10px;
    }
    .btn:active {
      transform: scale(0.97);
    }
    .center {
      text-align: center;
    }
    #question-text {
      font-size: 18px;
      margin: 30px 0 10px;
      text-align: center;
      line-height: 1.5;
      min-height: 80px;
    }
    #choices-text {
      font-size: 14px;
      white-space: pre-line;
      margin-bottom: 10px;
      min-height: 40px;
    }
    #status-text {
      font-size: 14px;
      text-align: center;
      min-height: 24px;
    }
    .ox-buttons,
    .mc-buttons {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-bottom: 15px;
    }
    .ox-btn {
      width: 90px;
      height: 90px;
      font-size: 30px;
      border-radius: 50%;
    }
    .mc-btn {
      width: 60px;
      height: 60px;
      font-size: 20px;
      border-radius: 50%;
    }
    .hidden {
      display: none;
    }
    /* 오답 팝업 오버레이 */
    #wrong-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.35);
      display: none;           /* 처음에는 무조건 안 보이게 */
      justify-content: center;
      align-items: center;
      z-index: 999;
    }
    #wrong-popup {
      background: #fff;
      padding: 18px 24px;
      border-radius: 10px;
      max-width: 260px;
      text-align: center;
      box-shadow: 0 4px 12px rgba(0,0,0,0.25);
    }
    #wrong-popup-message {
      font-size: 15px;
      margin-bottom: 16px;
    }
    .version-label {
      position: absolute;
      right: 8px;
      bottom: 8px;
      font-size: 11px;
      color: #999;
    }
    .progress-label {
      position: absolute;
      right: 8px;
      top: 8px;
      font-size: 12px;
      color: #555;
    }
    @media (max-width: 480px) {
      .ox-btn {
        width: 80px;
        height: 80px;
        font-size: 28px;
      }
      .mc-btn {
        width: 52px;
        height: 52px;
        font-size: 18px;
      }
      .app {
        margin: 8px;
        padding: 16px;
      }
    }
  </style>
</head>
<body>
<div class="app">
  <!-- 메인 메뉴 -->
  <div id="main-menu">
    <h1>퀴즈</h1>
    <div class="center">
      <button class="btn" id="btn-start">문제 풀기</button><br>
      <button class="btn" id="btn-review">오답 풀기</button><br>
      <button class="btn secondary small" id="btn-reset">기록 초기화</button>
    </div>
  </div>

  <!-- 문제 풀이 화면 -->
  <div id="quiz-screen" class="hidden">
    <div id="question-text"></div>
    <div id="choices-text"></div>

    <!-- OX 버튼 -->
    <div id="ox-buttons" class="ox-buttons hidden">
      <button class="btn ox-btn" id="btn-o">O</button>
      <button class="btn ox-btn" id="btn-x">X</button>
    </div>

    <!-- 객관식 버튼 (최대 4지선다) -->
    <div id="mc-buttons" class="mc-buttons hidden">
      <button class="btn mc-btn" data-idx="0">1</button>
      <button class="btn mc-btn" data-idx="1">2</button>
      <button class="btn mc-btn" data-idx="2">3</button>
      <button class="btn mc-btn" data-idx="3">4</button>
    </div>

    <div id="status-text"></div>
    <div class="center" style="margin-top: 10px;">
      <button class="btn secondary small" id="btn-back">메인 화면으로</button>
    </div>
  </div>

  <!-- 진행률 표시 -->
  <div id="progress-label" class="progress-label"></div>

  <!-- 버전 표시 (JS에서 자동으로 채움) -->
  <div id="version-label" class="version-label"></div>
</div>

<!-- 오답 팝업 -->
<div id="wrong-overlay">
  <div id="wrong-popup">
    <div id="wrong-popup-message">틀렸어 짜식아~</div>
    <button class="btn small" id="wrong-popup-close">다시 풀어봐</button>
  </div>
</div>

<script>
  // ================== 문제 데이터 (questions.json에서 로드) ==================
  let questions = [];
  let questionsLoaded = false;

  async function loadQuestions() {
    try {
      const res = await fetch("questions.json");
      if (!res.ok) {
        throw new Error("HTTP " + res.status);
      }
      const data = await res.json();
      if (!Array.isArray(data)) {
        throw new Error("JSON이 배열 형식이 아니다.");
      }

      // OX: {question, answer:"O"/"X", subject?}
      // MC: {question, type:"MC", choices:[..], answer_index:int, subject?}
      questions = data
        .filter(item => typeof item === "object" && item !== null)
        .map(item => {
          const q = String(item.question || "").trim();
          const subject = item.subject || null;
          const type = item.type || null;

          // MC 우선 판별
          if (type === "MC" || (Array.isArray(item.choices) && item.answer_index !== undefined)) {
            const choices = Array.isArray(item.choices) ? item.choices.map(String) : [];
            const answerIndex = parseInt(item.answer_index, 10);
            if (q && choices.length >= 2 && answerIndex >= 0 && answerIndex < choices.length) {
              return {
                question: q,
                subject,
                qtype: "MC",
                choices,
                answer_index: answerIndex
              };
            }
            return null;
          }

          // OX
          const a = String(item.answer || "").toUpperCase();
          if (q && (a === "O" || a === "X")) {
            return {
              question: q,
              subject,
              qtype: "OX",
              answer: a
            };
          }
          return null;
        })
        .filter(Boolean);

      questionsLoaded = true;
    } catch (e) {
      alert("문제 파일(questions.json)을 불러오는 중 에러났다.\n이것부터 해결해라.\n\n" + e);
      questions = [];
      questionsLoaded = false;
    }
  }

  // ================== 공통 유틸 ==================
  function shuffle(array) {
    const arr = array.slice();
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }


  // ================== 이어풀기(세션) 저장 ==================
  const SESSION_KEY = "oxquiz_session_v1";

  function buildQuestionBank() {
    const map = {};
    (questions || []).forEach(q => {
      if (q && q.question) map[q.question] = q;
    });
    return map;
  }

  function loadSessionRaw() {
    try {
      const raw = localStorage.getItem(SESSION_KEY);
      if (!raw) return null;
      const obj = JSON.parse(raw);
      if (!obj || typeof obj !== "object") return null;
      return obj;
    } catch (e) {
      return null;
    }
  }

  function saveSession() {
    // 진행 중일 때만 저장
    if (!mode || !currentList.length || currentIndex < 0 || currentIndex >= currentList.length) {
      localStorage.removeItem(SESSION_KEY);
      return;
    }
    const payload = {
      mode,
      index: currentIndex,
      order: currentList.map(q => q.question),
      status: statusText ? (statusText.textContent || "") : "",
      saved_at: new Date().toISOString()
    };
    localStorage.setItem(SESSION_KEY, JSON.stringify(payload));
  }

  function clearSession() {
    localStorage.removeItem(SESSION_KEY);
  }

  function hasInMemorySession(targetMode) {
    return mode === targetMode && currentList.length > 0 && currentIndex >= 0 && currentIndex < currentList.length;
  }

  function restoreSession(targetMode) {
    // 메모리에 이미 있으면 그걸로 쓴다
    if (hasInMemorySession(targetMode)) return true;

    const s = loadSessionRaw();
    if (!s || s.mode !== targetMode) return false;
    if (!questionsLoaded || !questions.length) return false;

    const bank = buildQuestionBank();
    const list = (s.order || []).map(t => bank[t]).filter(Boolean);
    if (!list.length) return false;

    mode = targetMode;
    currentList = list;
    currentIndex = Math.max(0, Math.min(parseInt(s.index, 10) || 0, currentList.length - 1));

    if (statusText) {
      if (s.status) statusText.textContent = s.status;
      else statusText.textContent = (targetMode === "review") ? "최근 7일 오답만 다시 푼다. 제대로 해라." : "";
    }
    return true;
  }

  function hasSavedSession(targetMode) {
    if (hasInMemorySession(targetMode)) return true;
    const s = loadSessionRaw();
    return !!(s && s.mode === targetMode && Array.isArray(s.order) && s.order.length);
  }

  function updateMainButtons() {
    if (btnStart) btnStart.textContent = hasSavedSession("normal") ? "문제 이어풀기" : "문제 풀기";
    if (btnReview) btnReview.textContent = hasSavedSession("review") ? "오답 이어풀기" : "오답 풀기";
  }

  function getTodayStr() {
    const d = new Date();
    const y = d.getFullYear();
    const m = String(d.getMonth() + 1).padStart(2, "0");
    const day = String(d.getDate()).padStart(2, "0");
    return `${y}-${m}-${day}`;
  }

  function formatDate(d) {
    const y = d.getFullYear();
    const m = String(d.getMonth() + 1).padStart(2, "0");
    const day = String(d.getDate()).padStart(2, "0");
    return `${y}-${m}-${day}`;
  }

  const STORAGE_PREFIX = "oxquiz_results_";

  function resultKeyFor(dateStr) {
    return STORAGE_PREFIX + dateStr;
  }

  function loadResultData(dateStr) {
    const key = resultKeyFor(dateStr);
    try {
      const raw = localStorage.getItem(key);
      if (!raw) return { correct: [], wrong: [] };
      const obj = JSON.parse(raw);
      if (!obj.correct) obj.correct = [];
      if (!obj.wrong) obj.wrong = [];
      return obj;
    } catch (e) {
      return { correct: [], wrong: [] };
    }
  }

  function saveResultData(dateStr, data) {
    const key = resultKeyFor(dateStr);
    localStorage.setItem(key, JSON.stringify(data));
  }

  function saveResultRecord(questionObj, userAnswer, correctAnswer, isCorrect) {
    const today = getTodayStr();
    const data = loadResultData(today);
    const record = {
      question: questionObj.question || "",
      correct_answer: correctAnswer,
      user_answer: userAnswer,
      is_correct: isCorrect,
      time: new Date().toISOString().replace("T", " ").slice(0, 19),
      subject: questionObj.subject || null,
      qtype: questionObj.qtype || "OX"
    };
    if (isCorrect) {
      data.correct.push(record);
    } else {
      data.wrong.push(record);
    }
    saveResultData(today, data);
  }

  function collectRecentWrongQuestions(allQuestions) {
    const bankMap = {};
    allQuestions.forEach(q => {
      bankMap[q.question] = q;
    });

    const today = new Date();
    const uniqueWrong = {};

    for (let i = 0; i < 7; i++) {
      const d = new Date(today);
      d.setDate(d.getDate() - i);
      const ds = formatDate(d);
      const data = loadResultData(ds);
      (data.wrong || []).forEach(item => {
        const qText = item.question;
        if (!qText) return;
        if (bankMap[qText] && !uniqueWrong[qText]) {
          uniqueWrong[qText] = bankMap[qText];
        }
      });
    }

    return Object.values(uniqueWrong);
  }

  // ================== 상태 / DOM 참조 ==================
  const mainMenu = document.getElementById("main-menu");
  const quizScreen = document.getElementById("quiz-screen");
  const questionText = document.getElementById("question-text");
  const choicesText = document.getElementById("choices-text");
  const statusText = document.getElementById("status-text");

  const btnStart = document.getElementById("btn-start");
  const btnReview = document.getElementById("btn-review");
  const btnReset = document.getElementById("btn-reset");
  const btnBack = document.getElementById("btn-back");

  const oxButtons = document.getElementById("ox-buttons");
  const btnO = document.getElementById("btn-o");
  const btnX = document.getElementById("btn-x");

  const mcButtons = document.getElementById("mc-buttons");
  const mcBtnElems = Array.from(mcButtons.querySelectorAll(".mc-btn"));

  const wrongOverlay = document.getElementById("wrong-overlay");
  const wrongPopupMessage = document.getElementById("wrong-popup-message");
  const wrongPopupClose = document.getElementById("wrong-popup-close");

  const versionLabel = document.getElementById("version-label");
  const progressLabel = document.getElementById("progress-label");

  let currentList = [];
  let currentIndex = 0;
  let mode = null; // "normal" or "review"

  // ================== 화면 전환 ==================
  function showMainMenu() {
    quizScreen.classList.add("hidden");
    mainMenu.classList.remove("hidden");
    statusText.textContent = "";
    choicesText.textContent = "";
    // 메인에서는 진행률 숨김
    if (progressLabel) progressLabel.textContent = "";
    updateMainButtons();
  }

  function showQuizScreen() {
    mainMenu.classList.add("hidden");
    quizScreen.classList.remove("hidden");
  }

  // ================== 진행률 표시 ==================
  function updateProgress() {
    if (!progressLabel) return;
    if (!currentList.length || currentIndex < 0 || currentIndex >= currentList.length) {
      progressLabel.textContent = "";
      return;
    }
    const now = currentIndex + 1;
    const total = currentList.length;
    progressLabel.textContent = `${now} / ${total}`;
  }

  // ================== 문제 표시 ==================
  function showCurrentQuestion() {
    if (!currentList.length) {
      questionText.textContent = "문제가 없다. 데이터부터 채워라.";
      choicesText.textContent = "";
      oxButtons.classList.add("hidden");
      mcButtons.classList.add("hidden");
      updateProgress();
      return;
    }
    if (currentIndex < 0 || currentIndex >= currentList.length) {
      questionText.textContent = "더 이상 풀 문제가 없다.";
      choicesText.textContent = "";
      oxButtons.classList.add("hidden");
      mcButtons.classList.add("hidden");
      updateProgress();
      return;
    }

    const q = currentList[currentIndex];
    questionText.textContent = q.question || "";
    const qtype = q.qtype || "OX";

    if (qtype === "MC") {
      // 객관식
      const choices = q.choices || [];
      const lines = choices.map((c, idx) => `${idx + 1}) ${c}`);
      choicesText.textContent = lines.join("\n");

      // 버튼 표시 개수 조절
      mcBtnElems.forEach(btn => btn.classList.add("hidden"));
      choices.forEach((_, idx) => {
        if (idx < mcBtnElems.length) {
          mcBtnElems[idx].textContent = String(idx + 1);
          mcBtnElems[idx].classList.remove("hidden");
        }
      });

      oxButtons.classList.add("hidden");
      mcButtons.classList.remove("hidden");
    } else {
      // OX
      choicesText.textContent = "";
      mcButtons.classList.add("hidden");
      oxButtons.classList.remove("hidden");
    }

    updateProgress();
  }

  function gotoNextQuestion() {
    currentIndex += 1;

    if (currentIndex >= currentList.length) {
      clearSession();
      alert("더 풀 문제 없다. 메인 화면으로 간다.");
      showMainMenu();
    } else {
      saveSession();
      statusText.textContent = "";
      showCurrentQuestion();
    }
  }

  // ================== 모드 시작 ==================
  function startNormalMode() {
    if (!questionsLoaded) {
      alert("문제도 아직 제대로 못 읽어왔다.\n잠깐 기다렸다가 다시 눌러라.");
      return;
    }
    if (!questions.length) {
      alert("문제가 없다. questions.json부터 채워라.");
      return;
    }
    // 이어풀기 세션이 있으면 먼저 물어본다
    if (hasSavedSession("normal")) {
      const ok = confirm("이전 문제풀이가 남아있다.\n이어서 풀래?\n(취소하면 새로 시작)");
      if (ok) {
        if (restoreSession("normal")) {
          showQuizScreen();
          showCurrentQuestion();
          saveSession();
          return;
        } else {
          clearSession();
        }
      } else {
        clearSession();
        updateMainButtons();
      }
    }

    mode = "normal";
    currentList = shuffle(questions);
    currentIndex = 0;
    statusText.textContent = "";
    saveSession();
    showQuizScreen();
    showCurrentQuestion();
  }

  function startReviewMode() {
    if (!questionsLoaded) {
      alert("문제도 아직 제대로 못 읽어왔다.\n잠깐 기다렸다가 다시 눌러라.");
      return;
    }
    if (!questions.length) {
      alert("문제가 없다. questions.json부터 채워라.");
      return;
    }
    // 이어풀기 세션이 있으면 먼저 물어본다
    if (hasSavedSession("review")) {
      const ok = confirm("이전 오답풀이가 남아있다.\n이어서 풀래?\n(취소하면 새로 시작)");
      if (ok) {
        if (restoreSession("review")) {
          showQuizScreen();
          showCurrentQuestion();
          saveSession();
          return;
        } else {
          clearSession();
        }
      } else {
        clearSession();
        updateMainButtons();
      }
    }

    const wrongList = collectRecentWrongQuestions(questions);
    if (!wrongList.length) {
      alert("최근 7일 동안 틀린 것도 없다.\n잘난 척 좀 해도 되겠네.");
      return;
    }
    mode = "review";
    currentList = shuffle(wrongList);
    currentIndex = 0;
    statusText.textContent = "최근 7일 오답만 다시 푼다. 제대로 해라.";
    saveSession();
    showQuizScreen();
    showCurrentQuestion();
  }

  // ================== 오답 팝업 ==================
  function showWrongPopup(msg) {
    wrongPopupMessage.textContent = msg;
    wrongOverlay.style.display = "flex";
  }

  function hideWrongPopup() {
    wrongOverlay.style.display = "none";
  }

  wrongOverlay.addEventListener("click", (e) => {
    if (e.target === wrongOverlay) hideWrongPopup();
  });

  wrongPopupClose.addEventListener("click", hideWrongPopup);

  // ================== 답변 처리 ==================
  function handleAnswerOX(userAnswer) {
    if (!currentList.length) return;
    const q = currentList[currentIndex];
    const correct = String(q.answer || "").toUpperCase();
    const user = String(userAnswer || "").toUpperCase();
    const isCorrect = (user === correct);

    saveResultRecord(q, user, correct, isCorrect);

    if (isCorrect) {
      statusText.textContent = "정답이다. 이제 좀 한다?";
      setTimeout(() => { gotoNextQuestion(); }, 500);
    } else {
      statusText.textContent = "오답이다. 머리 식히고 다시 골라봐라.";
      const msgList = [
        "틀렸어 짜식아~",
        "어허, 이건 아니지.",
        "슷.",
        "이렇게 해선 내가 도움을 줄 수가 없어.",
        "죽는다 진짜.",
        "다시.",
        "또 다시.",
        "한 번 더."
      ];
      const msg = msgList[Math.floor(Math.random() * msgList.length)];
      showWrongPopup(msg);
    }
  }

  function handleAnswerMC(choiceIndex) {
    if (!currentList.length) return;
    const q = currentList[currentIndex];
    const choices = q.choices || [];
    const correctIndex = q.answer_index;

    const isCorrect = (choiceIndex === correctIndex);

    const userText = (choiceIndex >= 0 && choiceIndex < choices.length) ? choices[choiceIndex] : "";
    const correctText = (correctIndex >= 0 && correctIndex < choices.length) ? choices[correctIndex] : "";

    saveResultRecord(q, userText, correctText, isCorrect);

    if (isCorrect) {
      statusText.textContent = "정답이다. 괜찮네?";
      setTimeout(() => { gotoNextQuestion(); }, 500);
    } else {
      statusText.textContent = "오답이다. 보기나 다시 읽어라.";
      const msgList = [
        "틀렸어 짜식아~",
        "어허, 이건 아니지.",
        "슷.",
        "이렇게 해선 내가 도움을 줄 수가 없어.",
        "죽는다 진짜.",
        "다시.",
        "또 다시.",
        "한 번 더."
      ];
      const msg = msgList[Math.floor(Math.random() * msgList.length)];
      showWrongPopup(msg);
    }
  }

  // ================== 기록 초기화 ==================
  function resetAllResults() {
    if (!confirm("정말로 모든 기록을 싹 다 지울 거냐?\n(최근 7일 오답도 전부 사라진다.)")) {
      return;
    }
    const keysToRemove = [];
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key && key.startsWith(STORAGE_PREFIX)) {
        keysToRemove.push(key);
      }
    }
    keysToRemove.forEach(k => localStorage.removeItem(k));
    clearSession();
    updateMainButtons();
    alert("기록 싹 다 지워줬다. 다시 처음부터 해라.");
  }

  // ================== 이벤트 바인딩 ==================
  btnStart.addEventListener("click", startNormalMode);
  btnReview.addEventListener("click", startReviewMode);
  btnBack.addEventListener("click", () => {
    saveSession();
    showMainMenu();
  });
  btnReset.addEventListener("click", resetAllResults);

  btnO.addEventListener("click", () => handleAnswerOX("O"));
  btnX.addEventListener("click", () => handleAnswerOX("X"));

  mcBtnElems.forEach(btn => {
    btn.addEventListener("click", () => {
      const idx = parseInt(btn.getAttribute("data-idx"), 10);
      handleAnswerMC(idx);
    });
  });

  // 페이지 로드 시 문제 파일 먼저 로딩 + 버전 표시 세팅
  window.addEventListener("load", async () => {
    await loadQuestions();
    updateMainButtons();

    if (versionLabel) {
      const d = new Date(document.lastModified);
      if (!isNaN(d.getTime())) {
        const yyyy = d.getFullYear();
        const mm = String(d.getMonth() + 1).padStart(2, "0");
        const dd = String(d.getDate()).padStart(2, "0");
        versionLabel.textContent = `v${yyyy}.${mm}.${dd}`;
      } else {
        versionLabel.textContent = "v(unknown)";
      }
    }
  });
</script>
</body>
</html>
